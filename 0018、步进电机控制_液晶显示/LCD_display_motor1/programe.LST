C51 COMPILER V8.08   PROGRAME                                                              06/01/2008 22:40:39 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE PROGRAME
OBJECT MODULE PLACED IN programe.OBJ
COMPILER INVOKED BY: E:\keil\C51\BIN\C51.EXE programe.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <AT89X51.h> 
   2          #include <stdio.h>
   3          #include <math.h>
   4          #define uc unsigned char 
   5          #define ui unsigned int
   6          #define LCDPAGE 0xB8                              //设置页指令。
   7          #define LCDLINE 0x40                              //设置列指令。
   8           sbit E=        P3^5;
   9           sbit RW=P3^4;
  10           sbit RS=P3^2;
  11           sbit L=P3^1;                                            //左半平面 
  12           sbit R=P3^0;                                            //右半平面 
  13           sbit Busy=P2^7;//                                       //忙 判断位 
  14           uc scan_key1,scan_key2;                        //按键功能选择，00 停止，01 正转 10 反转 
  15           uc step1;step2;
  16           static  step_index;
  17           ui count1,count2;                                 //定时 
  18           uc butter;                                                     //按键 
  19           static  speed;                                         //速度参数 
  20            //;本文件为16×16点阵中文字库文件,字的横向8点构成一字节,左边点在字节的高               
  21          //位,字符点阵四角按左上角→右上角→左下角→右下角取字
  22          //;如你想在以后继续用HZDotReader打开文件,追加汉字点阵数据,请不要修改或增删所有注释        
  23          uc code JIANG[]=
  24          {
  25          //;江   CBDAD                                                           
  26           0x10,0x60,0x01,0xC6,0x30,0x00,0x04,0x04,
  27           0x04,0xFC,0x04,0x04,0x04,0x04,0x00,0x00,
  28           0x04,0x04,0x7E,0x01,0x20,0x20,0x20,0x20,
  29           0x20,0x3F,0x20,0x20,0x20,0x20,0x20,0x00,
  30          };
  31          uc code XI[]=
  32          {
  33          //;西   CCEF7                                            
  34           0x02,0xF2,0x12,0x12,0x12,0xFE,0x12,0x12,
  35           0x12,0xFE,0x12,0x12,0x12,0xF2,0x02,0x00,
  36           0x00,0x7F,0x28,0x24,0x22,0x21,0x20,0x20,
  37           0x20,0x21,0x22,0x22,0x22,0x7F,0x00,0x00,
  38          };
  39          uc code LI[]=
  40          {
  41          //;理   CC0ED
  42           0x44,0x44,0xFC,0x44,0x44,0x00,0xFE,0x92,
  43           0x92,0xFE,0x92,0x92,0x92,0xFE,0x00,0x00,
  44           0x10,0x10,0x0F,0x08,0x48,0x40,0x45,0x44,
  45           0x44,0x7F,0x44,0x44,0x44,0x45,0x40,0x00,
  46          };
  47          uc GONG[]=
  48          {
  49          //;工   CB9A4
  50           0x00,0x00,0x02,0x02,0x02,0x02,0x02,0xFE,
  51           0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x00,
  52           0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3F,
  53           0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,
  54          };
  55          uc code DA[]=
C51 COMPILER V8.08   PROGRAME                                                              06/01/2008 22:40:39 PAGE 2   

  56          {
  57          //;大   CB4F3
  58           0x20,0x20,0x20,0x20,0x20,0x20,0xA0,0x7F,
  59           0xA0,0x20,0x20,0x20,0x20,0x30,0x20,0x00,
  60           0x00,0x40,0x40,0x20,0x10,0x0C,0x03,0x00,
  61           0x01,0x06,0x08,0x10,0x20,0x60,0x20,0x00
  62          };
  63          uc XUE[]=
  64          {
  65          //;学   CD1A7
  66           0x40,0x30,0x10,0x12,0x5C,0x54,0x50,0x51,
  67           0x5E,0xD4,0x50,0x18,0x57,0x32,0x10,0x00,
  68           0x00,0x02,0x02,0x02,0x02,0x02,0x42,0x82,
  69           0x7F,0x02,0x02,0x02,0x02,0x02,0x02,0x00,
  70          };
  71          uc code ZI[]=                                                           //自动化 
  72          {  
  73          0x00,0x00,0x00,0xF8,0x48,0x48,0x4C,0x4B,
  74          0x4A,0x48,0x48,0x48,0xF8,0x00,0x00,0x00,
  75          0x00,0x00,0x00,0xFF,0x44,0x44,0x44,0x44,
  76          0x44,0x44,0x44,0x44,0xFF,0x00,0x00,0x00,
  77          };
  78          uc code DONG[]=
  79          {
  80          0x20,0x24,0x24,0xE4,0x24,0x24,0x24,0x20,
  81          0x10,0x10,0xFF,0x10,0x10,0xF0,0x00,0x00,
  82          0x08,0x1C,0x0B,0x08,0x0C,0x05,0x4E,0x24,
  83          0x10,0x0C,0x03,0x20,0x40,0x3F,0x00,0x00,
  84          };
  85          uc code HUA[]=
  86          {       
  87          0x80,0x40,0x20,0xF8,0x07,0x02,0x00,0x00,
  88          0xFF,0xC0,0x60,0x30,0x1C,0x08,0x00,0x00,
  89          0x00,0x00,0x00,0x7F,0x00,0x04,0x02,0x01,
  90          0x3F,0x40,0x40,0x40,0x40,0x78,0x00,0x00,
  91          };
  92           uc code CHANG[]=                                                //常 
  93          {
  94          0x20,0x18,0x08,0x09,0xEE,0xAA,0xA8,0xAF,
  95          0xA8,0xA8,0xEC,0x0B,0x2A,0x18,0x08,0x00,
  96          0x00,0x00,0x3E,0x02,0x02,0x02,0x02,0xFF,
  97          0x02,0x02,0x12,0x22,0x1E,0x00,0x00,0x00,
  98          };
  99          uc code YUN[]=                                                     //运 
 100          {
 101          0x40,0x41,0xCE,0x04,0x00,0x20,0x22,0xA2,
 102          0x62,0x22,0xA2,0x22,0x22,0x22,0x20,0x00,
 103          0x40,0x20,0x1F,0x20,0x28,0x4C,0x4A,0x49,
 104          0x48,0x4C,0x44,0x45,0x5E,0x4C,0x40,0x00,
 105          };
 106          uc code XING[]=                                                   //行 
 107          {
 108          0x10,0x08,0x84,0xC6,0x73,0x22,0x40,0x44,
 109          0x44,0x44,0xC4,0x44,0x44,0x44,0x40,0x00,
 110          0x02,0x01,0x00,0xFF,0x00,0x00,0x00,0x00,
 111          0x40,0x80,0x7F,0x00,0x00,0x00,0x00,0x00,
 112          };
 113           uc code ZHENG[ ] = 
 114          {
 115          /*正   CD5FD */
 116          0x00,0x02,0x02,0xC2,0x02,0x02,0x02,0x02,
 117          0xFE,0x82,0x82,0x82,0x82,0x82,0x02,0x00,
C51 COMPILER V8.08   PROGRAME                                                              06/01/2008 22:40:39 PAGE 3   

 118          0x20,0x20,0x20,0x3F,0x20,0x20,0x20,0x20,
 119          0x3F,0x20,0x20,0x20,0x20,0x20,0x20,0x00,
 120          };
 121           uc code ZHUAN[ ] = 
 122           {
 123          /*转   CD7AA */
 124          0xC8,0xA8,0x9C,0xEB,0x88,0x88,0x88,0x40,
 125          0x48,0xF8,0x4F,0x48,0x48,0x48,0x40,0x00,
 126          0x08,0x08,0x04,0xFF,0x04,0x04,0x00,0x02,
 127          0x0B,0x12,0x22,0xD2,0x0E,0x02,0x00,0x00,
 128          };
 129          uc code FAN[ ] = 
 130          {
 131                  /*反   CB7B4 */
 132          
 133          0x00,0x00,0xFE,0x12,0x72,0x92,0x12,0x12,
 134          0x12,0x11,0x91,0x71,0x01,0x00,0x00,0x00,
 135          0x40,0x30,0x4F,0x40,0x20,0x21,0x12,0x0C,
 136          0x0C,0x12,0x11,0x20,0x60,0x20,0x00,0x00,
 137          };
 138           uc code TING[] = 
 139          {
 140                  /*停   CCDA3 */
 141          0x80,0x40,0x20,0xF8,0x07,0x02,0x04,0x74,
 142          0x54,0x55,0x56,0x54,0x74,0x04,0x04,0x00,
 143          0x00,0x00,0x00,0xFF,0x00,0x03,0x01,0x05,
 144          0x45,0x85,0x7D,0x05,0x05,0x05,0x03,0x00,
 145          };
 146          uc code ZHI[ ] = 
 147          {
 148          /*止   CD6B9 */
 149          0x00,0x00,0x00,0x00,0xF0,0x00,0x00,0x00,
 150          0xFF,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
 151          0x40,0x40,0x40,0x40,0x7F,0x40,0x40,0x40,
 152          0x7F,0x40,0x40,0x40,0x40,0x40,0x40,0x00,
 153          };
 154          uc code JIA[]=                                                           //加 
 155          {  
 156          0x00,0x08,0x08,0x08,0xFF,0x08,0x08,0xF8,
 157          0x00,0xF8,0x08,0x08,0x08,0xF8,0x00,0x00,
 158          0x40,0x20,0x18,0x07,0x00,0x20,0x40,0x3F,
 159          0x00,0x7F,0x10,0x10,0x10,0x3F,0x00,0x00, 
 160          };
 161          uc code SU[]=                                                           //速 
 162          {  
 163          0x40,0x42,0xCC,0x00,0x04,0xE4,0x24,0x24,
 164          0xFF,0x24,0x24,0x24,0xE4,0x04,0x00,0x00,
 165          0x40,0x20,0x1F,0x20,0x48,0x49,0x45,0x43,
 166          0x7F,0x41,0x43,0x45,0x4D,0x40,0x40,0x00,
 167          };
 168          uc code JIAN[]=                                                    //减 
 169          {
 170          0x00,0x02,0xEC,0x00,0xF8,0x28,0x28,0x28,
 171          0x28,0x28,0xFF,0x08,0x8A,0xEC,0x48,0x00,
 172          0x02,0x5F,0x20,0x18,0x07,0x00,0x1F,0x49,
 173          0x5F,0x20,0x13,0x0C,0x13,0x20,0x78,0x00,
 174          };                                                                                 //输出空白区域 
 175          uc code BAI[]=
 176          {
 177          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 178          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 179          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
C51 COMPILER V8.08   PROGRAME                                                              06/01/2008 22:40:39 PAGE 4   

 180          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 181          };
 182          uc code DI[]=                                                      //低 
 183          {                                
 184          0x40,0x20,0xF0,0x0C,0x07,0x02,0xFC,0x44,
 185          0x44,0x42,0xFE,0x43,0x43,0x42,0x40,0x00,
 186          0x00,0x00,0x7F,0x00,0x00,0x00,0x7F,0x20,
 187          0x10,0x28,0x43,0x0C,0x10,0x20,0x78,0x00,
 188          };
 189          //////////////////函数声明 **************////////
 190          //************************************************
 191          void iniLCD(void);                                                         
 192          void chkbusy(void);
 193          void wcode(uc cd) ;
 194          void wdata(uc dat);
 195          void disrow(uc page,uc col,uc *temp);
 196          void display( uc page,uc col,uc *temp);
 197          void ground(step);                                   //转步 
 198          void run1();                                     //正转 
 199          void run2();
 200          void stop();
 201          void delay(ui time);
 202          //************************************
 203          //**************LCD初始化 *************** 
 204          //*********************************
 205          void iniLCD(void)                               //初始化 
 206          { L=1;R=1;
 207   1        wcode(0x38);
 208   1        wcode(0x0f);                                  //开显示 设置 
 209   1        wcode(0xc0);                                    //设置显示启动为第一行 
 210   1        wcode(0x01);                                      //清屏
 211   1        wcode(0x06);                                          //画面不动，光标右移。
 212   1      }
 213          //******************LCD判断忙的子程序**********
 214          //**********************************************8
 215           void chkbusy(void)                              //   测LCD忙状态 
 216          { 
 217   1        E=1;                                                         //使能LCD
 218   1        RS=0;                                                        //读写指令 
 219   1        RW=1;                                                           //读 
 220   1        P2=0xff;                                                     //读操作前先进行一次空读操作 ，接下来才能读到数据 
 221   1        while(!Busy);                                          //等待，不忙退出 
 222   1       }
 223           //*****************************************
 224           //*****************写指令代码*****************
 225          //***********************************************
 226          void wcode(uc cd)                                       //写指令 代码 
 227          { 
 228   1        chkbusy();                                                         //写等待 
 229   1        P2=0xff;                                                                        //使能LCD
 230   1        RW=0;                                                                  //读禁止 
 231   1        RS=0;                                                                  //输出 设置 
 232   1        P2=cd;                                                                 //写数据代码 
 233   1        E=1;                                                                   //以下两句产生下降沿 
 234   1        E=0;                                                 // 
 235   1      }
 236          //*******************把显示数据写到内存单元中 *****************
 237          void wdata(uc dat)                                         //写显示数据
 238          {
 239   1        chkbusy();                                                            //写等待 
 240   1        P2=0xff;                                                                           //使能LCD
 241   1        RW=0;                                                                            //读禁止 
C51 COMPILER V8.08   PROGRAME                                                              06/01/2008 22:40:39 PAGE 5   

 242   1        RS=1;                                                                          //输出 设置 
 243   1        P2=dat;                                                                       //写数据代码 
 244   1        E=1;                                                                           //以下两句产生下降沿 
 245   1        E=0;                                                         // 
 246   1       }
 247           //***********************************************
 248           //****************显示LCD程序********************
 249           //*****************可以更改程序中的64变为32就可以输出数字了**********
 250           //****************************************************************
 251           //*************还可以换成生成图片的形式，具体****************
 252           ///****************************************************
 253          void  disrow(uc page,uc col,uc *temp)
 254           { 
 255   1        uc i;
 256   1        if(col<64)                                            // 左半平面
 257   1        { 
 258   2          L=1;R=0;
 259   2              wcode(LCDPAGE+page);                               // 写指令 页 
 260   2              wcode(LCDLINE+col);                                    //写指令行 
 261   2              if((col+16)<64)                                       //如果字在左半平面显示不了，转到右半平面去 
 262   2              { 
 263   3               for(i=0;i<16;i++)                                    //写字 
 264   3               wdata(*(temp+i));
 265   3               }
 266   2               else                                                         //右半平面 
 267   2               {
 268   3               for(i=0;i<64-col;i++)                           //减去左边数，从右半平面第一位开始显示 
 269   3               wdata(*(temp+i));                                       //写字 显示 
 270   3               L=0;R=1;                                                        //右半平面 
 271   3           wcode(LCDPAGE+page);                            // 写指令 页 
 272   3           wcode(LCDLINE);                                   //写指令行 
 273   3               for(i=64-col;i<16;i++)                          //写字 右半平面 
 274   3               wdata(*(temp+i));
 275   3           }
 276   2         }
 277   1         else
 278   1         {  
 279   2           L=0;R=1;
 280   2           wcode(LCDPAGE+page);                          // 写指令 页 
 281   2           wcode(LCDLINE+col-64);                           //写指令行 
 282   2               for(i=0;i<16;i++)                                    //写字 
 283   2               wdata(*(temp+i)); 
 284   2              }
 285   1      }
 286          //*********************供调用 ****子程序 *************
 287          //****************************************
 288          void  display( uc page,uc col,uc *temp)
 289          { 
 290   1              disrow( page, col, temp);                       //显示上半字 
 291   1                      disrow( page+1, col, temp+16);               //显示下半字 
 292   1      } 
 293          //***********************主***控****程********序********************
 294          //******************************************************************
 295          //***************程序完成于2008年6月 1日，儿童节********************
 296          //***************程序员：韩福伟************************************
 297          //**********江西理工大学应用科学学院机电学部自动化******************
 298          //******************************************************************
 299          //*********
 300          void main(void) 
 301          {  
 302   1         P2=0xff;
 303   1         iniLCD();                                      //初始化 LCD
C51 COMPILER V8.08   PROGRAME                                                              06/01/2008 22:40:39 PAGE 6   

 304   1         display(0,0x00,&JIANG);                         //    江 
 305   1         display(0,0x10,&XI);                            //    西 
 306   1         display(0,0x20,&LI);                            //   理 
 307   1         display(0,0x30,&GONG);                         //   工 
 308   1         display(0,0x40,&DA);                            //  大 
 309   1         display(0,0x50,&XUE);                            //  学 
 310   1         step2=0;
 311   1         step1=0;
 312   1         P1=0xff;
 313   1         P0=0;
 314   1         EX1=1;
 315   1         EA=1;                                               //开中断 
 316   1         speed=2010;
 317   1         while(1)
 318   1        {  
 319   2           if((scan_key1==1)&(scan_key2==0))             // 正转 
 320   2               {  
 321   3                  display(6,0x00,&ZHENG);                     //  LCD显示 
 322   3              display(6,0x10,&ZHUAN);
 323   3                  ground(step_index);
 324   3                  delay(speed);
 325   3                  step_index++;                                                  //大于7，从头再来 
 326   3                  if(step_index>7)
 327   3                      step_index=0; 
 328   3                }
 329   2               if((scan_key1==0)&(scan_key2==1))                 //反转 
 330   2               {                                                                  
 331   3                 ground(step_index);
 332   3                 display(6,0x00,&FAN);                      //         LCD显示 
 333   3             display(6,0x10,&ZHUAN);
 334   3                 delay(speed);
 335   3                 step_index--;
 336   3                 if(step_index<0)                                                     //小于0，从头再来。 
 337   3                      step_index=7;
 338   3                }
 339   2               if(scan_key1==0&scan_key2==0)
 340   2                { 
 341   3                 display(6,0x00,&TING);                     //        停止 
 342   3             display(6,0x10,&ZHI);
 343   3                 display(6,0x20,&BAI);
 344   3                 display(6,0x30,&BAI);
 345   3                 P0=0xff;
 346   3                }
 347   2               if(step1==1&step2==0)
 348   2                { 
 349   3                  speed=speed-100;
 350   3                      if(speed<200|speed==200)                                   //小于话，说明电机的速度不能再提高了。
 351   3                      { speed=200;                                                       //speed参数自己设定，以下遇到也是一样的。我只是一个乱写的值
 352   4                        display(6,0x20,&ZHENG);                                //正常运行 
 353   4                        display(6,0x30,&CHANG);
 354   4                        display(6,0x40,&YUN);
 355   4                        display(6,0x50,&XING);
 356   4                       }
 357   3                       else                                           //加速 
 358   3                      {
 359   4                       display(6,0x20,&JIA);
 360   4                       display(6,0x30,&SU);
 361   4                      }
 362   3                }
 363   2                if(step1==0&step2==1)
 364   2                { 
 365   3                  speed=speed+100;                           //这里面的参数，论实际情况更改 
C51 COMPILER V8.08   PROGRAME                                                              06/01/2008 22:40:39 PAGE 7   

 366   3                      if(speed>2500|speed==2500)                        //如果 小于了，就说明到饿低速，可以用停止按键停止。
 367   3                      { speed=2500;                                              //低速运行 
 368   4                        display(6,0x20,&DI);
 369   4                        display(6,0x30,&SU);
 370   4                        display(6,0x40,&YUN);
 371   4                        display(6,0x50,&XING);
 372   4                       }
 373   3                        else
 374   3                        {
 375   4                        display(6,0x20,&JIAN);                    //减速 
 376   4                        display(6,0x30,&SU);
 377   4                        }
 378   3                }
 379   2       }
 380   1      }
 381          //***************************************************
 382          //*************************     延时子程序**************
 383          //**************************************************
 384          void delay(ui time)                                 ///延时程序 
 385          { for (count1=0;count1<time;count1++ )                  //此处可以用中断进行准确定时。我只是瞎定了几个参数 
 386   1        for(count2=0;count2<3;count2++);
 387   1      }
 388          //*********************************************************
 389          //******************按键处理程序****************************
 390          //************************************************************
 391          void key(void) interrupt 2
 392          { 
 393   1        uc i;
 394   1        for(i=0;i<200;i++);                                              //延时防抖 
 395   1        if(P3_3==0)                                                   
 396   1         { 
 397   2          butter=~P1;
 398   2          switch(butter)
 399   2               {case 0x01:    scan_key1=1;scan_key2=0; break;        //正常运行 ，用两个数字进行选择，是不错的办法
 400   3                case 0x02:    scan_key1=0;scan_key2=0;break;        //停止 
 401   3                case 0x04:    scan_key1=0 ;scan_key2=1; break;      //加速 
 402   3                case 0x08:    step1=1;step2=0;break;               //减速 
 403   3                case 0x10:    step1=0;step2=1;break;              //正转 
 404   3                default :                ;                             //其它值返回 
 405   3               }
 406   2         }
 407   1         P1=0XFF;
 408   1      }
 409          //**************************************************
 410          //**********************转步************************
 411          //**************************************************
 412          void ground(step_index)  //转步 
 413          { 
 414   1       switch(step_index)
 415   1         {
 416   2           case 0://0            // 这里就说明了同步电机是怎么转的。我本来是用了代码的，
 417   2            P0_0 = 1;            //但是后来考虑了一些初学者不懂同步电机到底怎么转的
 418   2            P0_1 = 0;            //我就换成这个了， 知道怎么转的人，就换成代码把，一样的
 419   2            P0_2 = 0;
 420   2            P0_3 = 0;
 421   2            break;
 422   2                case 1://0,1  
 423   2            P0_0 = 1;
 424   2            P0_1 = 1;
 425   2            P0_2 = 0;
 426   2            P0_3 = 0;
 427   2            break;
C51 COMPILER V8.08   PROGRAME                                                              06/01/2008 22:40:39 PAGE 8   

 428   2                case 2://1
 429   2            P0_0 = 0;
 430   2            P0_1 = 1;
 431   2            P0_2 = 0;
 432   2            P0_3 = 0;
 433   2            break;
 434   2                case 3://1,2 
 435   2            P0_0 = 0;
 436   2            P0_1 = 1;
 437   2            P0_2 = 1;
 438   2            P0_3 = 0;
 439   2            break;
 440   2                case 4://2 
 441   2            P0_0 = 0;
 442   2            P0_1 = 0;
 443   2            P0_2 = 1;
 444   2            P0_3 = 0;
 445   2            break;
 446   2                case 5://2,3 
 447   2            P0_0 = 0;
 448   2            P0_1 = 0;
 449   2            P0_2 = 1;
 450   2            P0_3 = 1;
 451   2            break;
 452   2                case 6://3 
 453   2            P0_0 = 0;
 454   2            P0_1 = 0;
 455   2            P0_2 = 0;
 456   2            P0_3 = 1;
 457   2            break;
 458   2                case 7://3,0 
 459   2            P0_0 = 0;
 460   2            P0_1 = 0;
 461   2            P0_2 = 0;
 462   2            P0_3 = 1;
 463   2        }     
 464   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1164    ----
   CONSTANT SIZE    =    640    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     78       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
