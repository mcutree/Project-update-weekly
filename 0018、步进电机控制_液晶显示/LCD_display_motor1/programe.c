#include <AT89X51.h> 
#include <stdio.h>
#include <math.h>
#define uc unsigned char 
#define ui unsigned int
#define LCDPAGE 0xB8				  //设置页指令。
#define LCDLINE 0x40				  //设置列指令。
 sbit E=	P3^5;
 sbit RW=P3^4;
 sbit RS=P3^2;
 sbit L=P3^1;						 //左半平面 
 sbit R=P3^0;						 //右半平面 
 sbit Busy=P2^7;//					 //忙 判断位 
 uc scan_key1,scan_key2;			//按键功能选择，00 停止，01 正转 10 反转 
 uc step1;step2;
 static  step_index;
 ui count1,count2;				   //定时 
 uc butter;							//按键 
 static  speed;						//速度参数 
  //;本文件为16×16点阵中文字库文件,字的横向8点构成一字节,左边点在字节的高		 
//位,字符点阵四角按左上角→右上角→左下角→右下角取字
//;如你想在以后继续用HZDotReader打开文件,追加汉字点阵数据,请不要修改或增删所有注释	  
uc code JIANG[]=
{
//;江   CBDAD								
 0x10,0x60,0x01,0xC6,0x30,0x00,0x04,0x04,
 0x04,0xFC,0x04,0x04,0x04,0x04,0x00,0x00,
 0x04,0x04,0x7E,0x01,0x20,0x20,0x20,0x20,
 0x20,0x3F,0x20,0x20,0x20,0x20,0x20,0x00,
};
uc code XI[]=
{
//;西   CCEF7						 
 0x02,0xF2,0x12,0x12,0x12,0xFE,0x12,0x12,
 0x12,0xFE,0x12,0x12,0x12,0xF2,0x02,0x00,
 0x00,0x7F,0x28,0x24,0x22,0x21,0x20,0x20,
 0x20,0x21,0x22,0x22,0x22,0x7F,0x00,0x00,
};
uc code LI[]=
{
//;理   CC0ED
 0x44,0x44,0xFC,0x44,0x44,0x00,0xFE,0x92,
 0x92,0xFE,0x92,0x92,0x92,0xFE,0x00,0x00,
 0x10,0x10,0x0F,0x08,0x48,0x40,0x45,0x44,
 0x44,0x7F,0x44,0x44,0x44,0x45,0x40,0x00,
};
uc GONG[]=
{
//;工   CB9A4
 0x00,0x00,0x02,0x02,0x02,0x02,0x02,0xFE,
 0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x00,
 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3F,
 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,
};
uc code DA[]=
{
//;大   CB4F3
 0x20,0x20,0x20,0x20,0x20,0x20,0xA0,0x7F,
 0xA0,0x20,0x20,0x20,0x20,0x30,0x20,0x00,
 0x00,0x40,0x40,0x20,0x10,0x0C,0x03,0x00,
 0x01,0x06,0x08,0x10,0x20,0x60,0x20,0x00
};
uc XUE[]=
{
//;学   CD1A7
 0x40,0x30,0x10,0x12,0x5C,0x54,0x50,0x51,
 0x5E,0xD4,0x50,0x18,0x57,0x32,0x10,0x00,
 0x00,0x02,0x02,0x02,0x02,0x02,0x42,0x82,
 0x7F,0x02,0x02,0x02,0x02,0x02,0x02,0x00,
};
uc code ZI[]=								//自动化 
{  
0x00,0x00,0x00,0xF8,0x48,0x48,0x4C,0x4B,
0x4A,0x48,0x48,0x48,0xF8,0x00,0x00,0x00,
0x00,0x00,0x00,0xFF,0x44,0x44,0x44,0x44,
0x44,0x44,0x44,0x44,0xFF,0x00,0x00,0x00,
};
uc code DONG[]=
{
0x20,0x24,0x24,0xE4,0x24,0x24,0x24,0x20,
0x10,0x10,0xFF,0x10,0x10,0xF0,0x00,0x00,
0x08,0x1C,0x0B,0x08,0x0C,0x05,0x4E,0x24,
0x10,0x0C,0x03,0x20,0x40,0x3F,0x00,0x00,
};
uc code HUA[]=
{	
0x80,0x40,0x20,0xF8,0x07,0x02,0x00,0x00,
0xFF,0xC0,0x60,0x30,0x1C,0x08,0x00,0x00,
0x00,0x00,0x00,0x7F,0x00,0x04,0x02,0x01,
0x3F,0x40,0x40,0x40,0x40,0x78,0x00,0x00,
};
 uc code CHANG[]=						 //常 
{
0x20,0x18,0x08,0x09,0xEE,0xAA,0xA8,0xAF,
0xA8,0xA8,0xEC,0x0B,0x2A,0x18,0x08,0x00,
0x00,0x00,0x3E,0x02,0x02,0x02,0x02,0xFF,
0x02,0x02,0x12,0x22,0x1E,0x00,0x00,0x00,
};
uc code YUN[]=							   //运 
{
0x40,0x41,0xCE,0x04,0x00,0x20,0x22,0xA2,
0x62,0x22,0xA2,0x22,0x22,0x22,0x20,0x00,
0x40,0x20,0x1F,0x20,0x28,0x4C,0x4A,0x49,
0x48,0x4C,0x44,0x45,0x5E,0x4C,0x40,0x00,
};
uc code XING[]=							  //行 
{
0x10,0x08,0x84,0xC6,0x73,0x22,0x40,0x44,
0x44,0x44,0xC4,0x44,0x44,0x44,0x40,0x00,
0x02,0x01,0x00,0xFF,0x00,0x00,0x00,0x00,
0x40,0x80,0x7F,0x00,0x00,0x00,0x00,0x00,
};
 uc code ZHENG[ ] = 
{
/*正   CD5FD */
0x00,0x02,0x02,0xC2,0x02,0x02,0x02,0x02,
0xFE,0x82,0x82,0x82,0x82,0x82,0x02,0x00,
0x20,0x20,0x20,0x3F,0x20,0x20,0x20,0x20,
0x3F,0x20,0x20,0x20,0x20,0x20,0x20,0x00,
};
 uc code ZHUAN[ ] = 
 {
/*转   CD7AA */
0xC8,0xA8,0x9C,0xEB,0x88,0x88,0x88,0x40,
0x48,0xF8,0x4F,0x48,0x48,0x48,0x40,0x00,
0x08,0x08,0x04,0xFF,0x04,0x04,0x00,0x02,
0x0B,0x12,0x22,0xD2,0x0E,0x02,0x00,0x00,
};
uc code FAN[ ] = 
{
	/*反   CB7B4 */

0x00,0x00,0xFE,0x12,0x72,0x92,0x12,0x12,
0x12,0x11,0x91,0x71,0x01,0x00,0x00,0x00,
0x40,0x30,0x4F,0x40,0x20,0x21,0x12,0x0C,
0x0C,0x12,0x11,0x20,0x60,0x20,0x00,0x00,
};
 uc code TING[] = 
{
	/*停   CCDA3 */
0x80,0x40,0x20,0xF8,0x07,0x02,0x04,0x74,
0x54,0x55,0x56,0x54,0x74,0x04,0x04,0x00,
0x00,0x00,0x00,0xFF,0x00,0x03,0x01,0x05,
0x45,0x85,0x7D,0x05,0x05,0x05,0x03,0x00,
};
uc code ZHI[ ] = 
{
/*止   CD6B9 */
0x00,0x00,0x00,0x00,0xF0,0x00,0x00,0x00,
0xFF,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
0x40,0x40,0x40,0x40,0x7F,0x40,0x40,0x40,
0x7F,0x40,0x40,0x40,0x40,0x40,0x40,0x00,
};
uc code JIA[]=								 //加 
{  
0x00,0x08,0x08,0x08,0xFF,0x08,0x08,0xF8,
0x00,0xF8,0x08,0x08,0x08,0xF8,0x00,0x00,
0x40,0x20,0x18,0x07,0x00,0x20,0x40,0x3F,
0x00,0x7F,0x10,0x10,0x10,0x3F,0x00,0x00, 
};
uc code SU[]=								//速 
{  
0x40,0x42,0xCC,0x00,0x04,0xE4,0x24,0x24,
0xFF,0x24,0x24,0x24,0xE4,0x04,0x00,0x00,
0x40,0x20,0x1F,0x20,0x48,0x49,0x45,0x43,
0x7F,0x41,0x43,0x45,0x4D,0x40,0x40,0x00,
};
uc code JIAN[]=							   //减 
{
0x00,0x02,0xEC,0x00,0xF8,0x28,0x28,0x28,
0x28,0x28,0xFF,0x08,0x8A,0xEC,0x48,0x00,
0x02,0x5F,0x20,0x18,0x07,0x00,0x1F,0x49,
0x5F,0x20,0x13,0x0C,0x13,0x20,0x78,0x00,
};										   //输出空白区域 
uc code BAI[]=
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
uc code DI[]=							   //低 
{				 
0x40,0x20,0xF0,0x0C,0x07,0x02,0xFC,0x44,
0x44,0x42,0xFE,0x43,0x43,0x42,0x40,0x00,
0x00,0x00,0x7F,0x00,0x00,0x00,0x7F,0x20,
0x10,0x28,0x43,0x0C,0x10,0x20,0x78,0x00,
};
//////////////////函数声明 **************////////
//************************************************
void iniLCD(void);							   
void chkbusy(void);
void wcode(uc cd) ;
void wdata(uc dat);
void disrow(uc page,uc col,uc *temp);
void display( uc page,uc col,uc *temp);
void ground(step);	                             //转步 
void run1();                                     //正转 
void run2();
void stop();
void delay(ui time);
//************************************
//**************LCD初始化 *************** 
//*********************************
void iniLCD(void)                               //初始化 
{ L=1;R=1;
  wcode(0x38);
  wcode(0x0f);	                                //开显示 设置 
  wcode(0xc0);	                                  //设置显示启动为第一行 
  wcode(0x01);	                                    //清屏
  wcode(0x06);	                                 	//画面不动，光标右移。
}
//******************LCD判断忙的子程序**********
//**********************************************8
 void chkbusy(void)	                         //   测LCD忙状态 
{ 
  E=1;				                               //使能LCD
  RS=0;				                               //读写指令 
  RW=1;				                                  //读 
  P2=0xff;			                               //读操作前先进行一次空读操作 ，接下来才能读到数据 
  while(!Busy);		                                 //等待，不忙退出 
 }
 //*****************************************
 //*****************写指令代码*****************
//***********************************************
void wcode(uc cd)	                                //写指令 代码 
{ 
  chkbusy();					                     //写等待 
  P2=0xff;						                	  //使能LCD
  RW=0;						                    	 //读禁止 
  RS=0;						                     	 //输出 设置 
  P2=cd;					                    	 //写数据代码 
  E=1;						                      	 //以下两句产生下降沿 
  E=0;                                                 // 
}
//*******************把显示数据写到内存单元中 *****************
void wdata(uc dat)	                                   //写显示数据
{
  chkbusy();					                        //写等待 
  P2=0xff;							                     //使能LCD
  RW=0;							                           //读禁止 
  RS=1;						                         	 //输出 设置 
  P2=dat;						                        //写数据代码 
  E=1;							                         //以下两句产生下降沿 
  E=0;                                                         // 
 }
 //***********************************************
 //****************显示LCD程序********************
 //*****************可以更改程序中的64变为32就可以输出数字了**********
 //****************************************************************
 //*************还可以换成生成图片的形式，具体****************
 ///****************************************************
void  disrow(uc page,uc col,uc *temp)
 { 
  uc i;
  if(col<64)	                                        // 左半平面
  { 
    L=1;R=0;
	wcode(LCDPAGE+page);                               // 写指令 页 
	wcode(LCDLINE+col);	                               //写指令行 
	if((col+16)<64)		                              //如果字在左半平面显示不了，转到右半平面去 
	{ 
	 for(i=0;i<16;i++)	                              //写字 
	 wdata(*(temp+i));
	 }
	 else				                              //右半平面 
	 {
  	 for(i=0;i<64-col;i++)	                         //减去左边数，从右半平面第一位开始显示 
	 wdata(*(temp+i));		                         //写字 显示 
	 L=0;R=1;				                         //右半平面 
     wcode(LCDPAGE+page);                            // 写指令 页 
     wcode(LCDLINE);	                               //写指令行 
  	 for(i=64-col;i<16;i++)	                         //写字 右半平面 
	 wdata(*(temp+i));
     }
   }
   else
   {  
     L=0;R=1;
     wcode(LCDPAGE+page);                          // 写指令 页 
     wcode(LCDLINE+col-64);	                      //写指令行 
 	 for(i=0;i<16;i++)		                      //写字 
	 wdata(*(temp+i)); 
	}
}
//*********************供调用 ****子程序 *************
//****************************************
void  display( uc page,uc col,uc *temp)
{ 
        disrow( page, col, temp);	               	//显示上半字 
		disrow( page+1, col, temp+16);	             //显示下半字 
} 
//***********************主***控****程********序********************
//******************************************************************
//***************程序完成于2008年6月 1日，儿童节********************
//***************程序员：韩福伟************************************
//**********江西理工大学应用科学学院机电学部自动化******************
//******************************************************************
//*********
void main(void) 
{  
   P2=0xff;
   iniLCD();                                      //初始化 LCD
   display(0,0x00,&JIANG);                         //    江 
   display(0,0x10,&XI);	                           //    西 
   display(0,0x20,&LI);	                           //   理 
   display(0,0x30,&GONG);                         //   工 
   display(0,0x40,&DA);	                           //  大 
   display(0,0x50,&XUE);                            //	学 
   step2=0;
   step1=0;
   P1=0xff;
   P0=0;
   EX1=1;
   EA=1;	                                       //开中断 
   speed=2010;
   while(1)
  {  
     if((scan_key1==1)&(scan_key2==0))             // 正转 
	 {  
	    display(6,0x00,&ZHENG);                     //  LCD显示 
        display(6,0x10,&ZHUAN);
	    ground(step_index);
	    delay(speed);
   	    step_index++;					           //大于7，从头再来 
	    if(step_index>7)
	   	step_index=0; 
	  }
	 if((scan_key1==0)&(scan_key2==1))	           //反转 
	 {								    
	   ground(step_index);
	   display(6,0x00,&FAN);                      //	 LCD显示 
       display(6,0x10,&ZHUAN);
	   delay(speed);
   	   step_index--;
	   if(step_index<0)							//小于0，从头再来。 
	   	step_index=7;
	  }
	 if(scan_key1==0&scan_key2==0)
	  { 
	   display(6,0x00,&TING);                     //	停止 
       display(6,0x10,&ZHI);
	   display(6,0x20,&BAI);
	   display(6,0x30,&BAI);
	   P0=0xff;
	  }
	 if(step1==1&step2==0)
	  { 
	    speed=speed-100;
		if(speed<200|speed==200)				   //小于话，说明电机的速度不能再提高了。
		{ speed=200;							   //speed参数自己设定，以下遇到也是一样的。我只是一个乱写的值
		  display(6,0x20,&ZHENG);				 //正常运行 
		  display(6,0x30,&CHANG);
		  display(6,0x40,&YUN);
		  display(6,0x50,&XING);
		 }
		 else						//加速 
		{
		 display(6,0x20,&JIA);
		 display(6,0x30,&SU);
		}
	  }
	  if(step1==0&step2==1)
	  { 
	    speed=speed+100;		               //这里面的参数，论实际情况更改 
		if(speed>2500|speed==2500)			  //如果 小于了，就说明到饿低速，可以用停止按键停止。
	 	{ speed=2500;						   //低速运行 
		  display(6,0x20,&DI);
		  display(6,0x30,&SU);
		  display(6,0x40,&YUN);
		  display(6,0x50,&XING);
		 }
		  else
		  {
		  display(6,0x20,&JIAN);	            //减速 
		  display(6,0x30,&SU);
		  }
	  }
 }
}
//***************************************************
//*************************	延时子程序**************
//**************************************************
void delay(ui time)	                            ///延时程序 
{ for (count1=0;count1<time;count1++ )			//此处可以用中断进行准确定时。我只是瞎定了几个参数 
  for(count2=0;count2<3;count2++);
}
//*********************************************************
//******************按键处理程序****************************
//************************************************************
void key(void) interrupt 2
{ 
  uc i;
  for(i=0;i<200;i++);						   //延时防抖 
  if(P3_3==0)							
   { 
    butter=~P1;
    switch(butter)
	 {case 0x01:    scan_key1=1;scan_key2=0; break;        //正常运行 ，用两个数字进行选择，是不错的办法
 	  case 0x02:    scan_key1=0;scan_key2=0;break;        //停止 
	  case 0x04:    scan_key1=0 ;scan_key2=1; break;      //加速 
	  case 0x08:    step1=1;step2=0;break;               //减速 
	  case 0x10:    step1=0;step2=1;break;              //正转 
	  default :  		   ;                             //其它值返回 
	 }
   }
   P1=0XFF;
}
//**************************************************
//**********************转步************************
//**************************************************
void ground(step_index)	 //转步 
{ 
 switch(step_index)
   {
     case 0://0 	   // 这里就说明了同步电机是怎么转的。我本来是用了代码的，
      P0_0 = 1;		   //但是后来考虑了一些初学者不懂同步电机到底怎么转的
      P0_1 = 0;		   //我就换成这个了， 知道怎么转的人，就换成代码把，一样的
      P0_2 = 0;
      P0_3 = 0;
      break;
	  case 1://0,1  
      P0_0 = 1;
      P0_1 = 1;
      P0_2 = 0;
      P0_3 = 0;
      break;
	  case 2://1
      P0_0 = 0;
      P0_1 = 1;
      P0_2 = 0;
      P0_3 = 0;
      break;
	  case 3://1,2 
      P0_0 = 0;
      P0_1 = 1;
      P0_2 = 1;
      P0_3 = 0;
      break;
	  case 4://2 
      P0_0 = 0;
      P0_1 = 0;
      P0_2 = 1;
      P0_3 = 0;
      break;
	  case 5://2,3 
      P0_0 = 0;
      P0_1 = 0;
      P0_2 = 1;
      P0_3 = 1;
      break;
	  case 6://3 
      P0_0 = 0;
      P0_1 = 0;
      P0_2 = 0;
      P0_3 = 1;
      break;
	  case 7://3,0 
      P0_0 = 0;
      P0_1 = 0;
      P0_2 = 0;
      P0_3 = 1;
  }	
}